(this) => {
  let type = this.type
  let fds = this.fds
  let vds = this.vds
  let strictMode = this.strictMode

  // 1. Let env be the environment record component of the running execution context’s VariableEnvironment.
  let env = ExecutionContext.VariableEnvironment.EnvironmentRecord
  // 2. If code is eval code, then let configurableBindings be true else let configurableBindings be false.
  if (= type "code") let configurableBindings = true else let configurableBindings = false
  // 3. If code is strict mode code, then let strict be true else let strict be false.
  if strictMode let strict = true else let strict = false
  // 4. If code is function code, then
  if (= type "function") {
    ??? "10.5"
    // a. Let func be the function whose [[Call]] internal method initiated execution of code. Let names be the value of func’s [[FormalParameters]] internal property.
    // b. Let argCount be the number of elements in args.
    // c. Let n be the number 0.
    // d. For each String argName in names, in list order do
    // i. Let n be the current value of n plus 1.
    // ii. If n is greater than argCount, let v be undefined otherwise let v be the value of the n’th element of args.
    // iii. Let argAlreadyDeclared be the result of calling env’s HasBinding concrete method passing argName as the argument.
    // iv. If argAlreadyDeclared is false, call env’s CreateMutableBinding concrete method passing argName as the argument.
    // v. Call env’s SetMutableBinding concrete method passing argName, v, and strict as the arguments.
  }
  // 5. For each FunctionDeclaration f in code, in source text order do
  let i = i0
  while (< i fds.length) {
    ??? "10.5"
    // a. Let fn be the Identifier in FunctionDeclaration f.
    // b. Let fo be the result of instantiating FunctionDeclaration f as described in Clause 13.
    // c. Let funcAlreadyDeclared be the result of calling env’s HasBinding concrete method passing fn as the argument.
    // d. If funcAlreadyDeclared is false, call env’s CreateMutableBinding concrete method passing fn and configurableBindings as the arguments.
    // e. Else if env is the environment record component of the global environment then
    // i. Let go be the global object.
    // ii. Let existingProp be the resulting of calling the [[GetProperty]] internal method of go with argument fn.
    // iii. If existingProp .[[Configurable]] is true, then
    // 1. Call the [[DefineOwnProperty]] internal method of go, passing fn, Property Descriptor {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configurableBindings }, and true as arguments.
    // iv. Else if IsAccessorDescriptor(existingProp) or existingProp does not have attribute values {[[Writable]]: true, [[Enumerable]]: true}, then
    // 1. Throw a TypeError exception.
    // f. Call env’s SetMutableBinding concrete method passing fn, fo, and strict as the arguments.
    i = (+ i i1)
  }
  // 6. Let argumentsAlreadyDeclared be the result of calling env’s HasBinding concrete method passing "arguments" as the argument.
  let argumentsAlreadyDeclared = env.HasBinding(env, "arguments")
  // 7. If code is function code and argumentsAlreadyDeclared is false, then
  if (&& (= type "function") (= argumentsAlreadyDeclared false)) {
    ??? "10.5"
    // a. Let argsObj be the result of calling the abstract operation CreateArgumentsObject (10.6) passing func, names, args, env and strict as arguments.
    // b. If strict is true, then
    // i. Call env’s CreateImmutableBinding concrete method passing the String "arguments" as the argument.
    // ii. Call env’s InitializeImmutableBinding concrete method passing "arguments" and argsObj as arguments.
    // c. Else,
    // i. Call env’s CreateMutableBinding concrete method passing the String "arguments" as the argument.
    // ii. Call env’s SetMutableBinding concrete method passing "arguments", argsObj, and false as arguments.
  }
  // 8. For each VariableDeclaration and VariableDeclarationNoIn d in code, in source text order do
  let i = i0
  while (< i vds.length) {
    let d = vds[i]
    // a. Let dn be the Identifier in d.
    let dn = d.Identifier
    // b. Let varAlreadyDeclared be the result of calling env’s HasBinding concrete method passing dn as the argument.
    let varAlreadyDeclared = env.HasBinding(env, dn)
    // c. If varAlreadyDeclared is false, then
    if (= varAlreadyDeclared false) {
      // i. Call env’s CreateMutableBinding concrete method passing dn and configurableBindings as the arguments.
      let _ = env.CreateMutableBinding(env, dn, configurableBindings)
      // ii. Call env’s SetMutableBinding concrete method passing dn, undefined, and strict as the arguments.
      let _ = env.SetMutableBinding(env, dn, undefined, strict)
    }
    i = (+ i i1)
  }
}
